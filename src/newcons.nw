% -*- mode: Noweb; noweb-code-mode: sml-mode -*-
% $Id: newcons.nw,v 1.5 1999/09/06 16:09:36 nr Exp $
% l2h ignore bug {
% l2h ignore change {

% l2h let htmlcontents tableofcontents
%\htmlcontents


\chapter{Constructors}
@
\section{Basic, abstract constructors}

Constructors have operands and types, and in this interface we support
\emph{properties} for constructors, operands, and types (``COT'').
@

\subsection{Basic types}
Inputs to constructors may be
\begin{itemize}
\item
Signed or unsigned integers.
In these cases, the width may be known explicitly, or it may be the
natural width of the \emph{host} machine.%
\footnote{The machine on which the toolkit runs, not the machine being
described.}
%Integers may be relocatable or not, as indicated by the flag.
\item
Operands of some known constructor type.
\item
Eventually,we may want to permit raw patterns to be constructor inputs.
\end{itemize}
%In addition to these inputs, a constructor may have operands that are
%simple syntactic sugar for use in deriving assembly-language syntax.
<<operand types>>=
datatype operand_type
  = INTEGER  of {signed : bool, width : int option}
  | INSTANCE of {family : int, typeid : int}
type 'o operand' = string * operand_type * 'o
@
To make all this functional, I assign a unique pair of integers to each
constructor.
One integer represents the constructor type, and the other represents
a particular constructor of that type.
These integers make sense only in terms of a particular ``constructor
family;'' different constructors are guaranteed to be tagged
differently only if they come from the same family.
The one piece of global state in the whole universe is the mapping of
small integers to families.
This mapping can't be polymorphic, so it has to be performed
elsewhere, when the types of the properties are known.
<<exported types>>=
type ('c, 'o, 't) family'		(* family of constructors and types *)
type ('c, 'o, 't) constype'		(* a constructor type *)
type ('c, 'o, 't) constructor'
@ 
I go through some major contortions in order to satisfy two goals:
\begin{itemize}
\item  Have a ``constructor
specification'' that has no tag while having a ``constructor'' with an
integer tag.
\item Hide the definition of constructor type within the module.
\end{itemize}
This would be easy except that constructors and constructor types are
mutually recursive (since a constructor type gives access to all of
its members).
<<exported types>>=
type ('c, 'o, 't) constructor_info' =
  { name : string			(* name of this constructor *)
  , operands : 'o operand' list
  , ty : ('c, 'o, 't) constype'		(* type of this constructor *)
  , region : SourceMap.region           (* defining region --- for error messages *)
  , sourcemap : SourceMap.sourcemap     (* to translate those error messages *)
  , property : 'c			(* an arbitrary property *)
  }
@
For now, anyway, a family and its constypes are mutable.
<<newcons.sig>>=
signature CONSTRUCTOR = sig
  <<operand types>>
  <<exported types>>
 
  (**************** family creation *********************)

  val newFamily' :  't -> ('c, 'o, 't) family'   
    (* create a mutable family with an empty, unnamed type *)
  val familyID : ('c, 'o, 't) family' -> int (* globally unique *)

  (**************** access to info about constructors ****************)

  val info : ('c, 'o, 't) constructor' -> ('c, 'o, 't) constructor_info'
  val fromId' :
       (int -> ('c, 'o, 't) family') -> { family : int, typeid : int, tag : int }
    -> ('c, 'o, 't) constructor'
  val fullId : ('c, 'o, 't) constructor' -> { family : int, typeid : int, tag : int }
  val tag    : ('c, 'o, 't) constructor' -> int

  (**************** convenient selection based on name of operand **********)

  val operandNamed : ('c, 'o, 't) constructor' * string -> 'o operand'
         (* find an operand; error if wrong *)
  val operandSelect : ('c, 'o, 't) constructor' * string * 'a list -> 'a 
         (* select item from list corresponding to operand (error if wrong) *)

  (**************** create and manipulate constructor types ****************)

  val unnamedConstype : ('c, 'o, 't) family' -> ('c, 'o, 't) constype'
  val freshConstype :
   ('c, 'o, 't) family' * {name : string} * 't -> ('c, 'o, 't) constype'
   (* mutators of constype *)
  val addConstructor : 
   ('c, 'o, 't) constructor_info' * ('c, 'o, 't) constype' -> ('c, 'o, 't) constructor'
  val replaceConstructor :
   ('c, 'o, 't) constructor_info' * ('c, 'o, 't) constype' -> ('c, 'o, 't) constructor'
         (* replace constructor of the same name *)

  val useConstype : ('c, 'o, 't) constype' -> unit
  val members : ('c, 'o, 't) constype' -> ('c, 'o, 't) constructor' list  (* constitutes a use *)
  val typeName : ('c, 'o, 't) constype' -> string option
  val typeid : ('c, 'o, 't) constype' -> { family : int, typeid : int }
  val typeFromId' : (int -> ('c, 'o, 't) family') -> { family : int, typeid : int }
                   -> ('c, 'o, 't) constype'
  val tagLimit : ('c, 'o, 't) constype' -> int (* tags in range 1..limit-1  --- constitutes use *)



  val allTypes : ('c, 'o, 't) family' -> ('c, 'o, 't) constype' list  (* returns in declaration order *)
  val constructors' : ('c, 'o, 't) family' -> ('c, 'o, 't) constructor' list
    (* constructors in *reverse* order of originally being added *)

end
@ N.B. constype must point to family so we can update list of constructors.
@ 
\section{SLED constructors}

A SLED constructor is one with certain properties---it has binary and
assembly-language representations, and each integer field may have a
relocatable flag and an optional associated field.
Note that these properties are fixed once for all at the time the
constructor is created.
To add properties later on, it pays to use the [[Map]] sub-structure.
<<sledcons.sig>>=
signature SLED_CONSTRUCTOR = sig
  include CONSTRUCTOR
  structure Patterns : PATTERNS
  structure Pattern : PATTERN
  sharing type Patterns.Latent.pattern = Pattern.pattern
  sharing Pattern.Exp = Patterns.Exp
  type disjunct = (Patterns.field, Patterns.latent) Patterns.cons_or_label
                       Patterns.sequence Patterns.disjunct'

  type operand_property = { relocatable : bool, field : Patterns.field option } 
  structure Syntax : sig
    datatype operand = LITERAL of string | OPERAND of operand_property operand'
  end
  type constructor_property = 
      { branches : Patterns.Latent.pattern list, syntax : Syntax.operand list }
  type constype_property = unit
  type operand = operand_property operand'
  type family = 
    (constructor_property, operand_property, constype_property) family'
  type constructor = 
    (constructor_property, operand_property, constype_property) constructor'
  type constype = 
    (constructor_property, operand_property, constype_property) constype'
  type constructor_info = 
    (constructor_property, operand_property, constype_property) constructor_info'

  val newFamily : unit -> family
  val familyFromId : int -> family
  val fromId     : { family : int, typeid : int, tag : int } -> constructor
  val typeFromId : { family : int, typeid : int            } -> constype


  (**************** patterns on right-hand sides ****************)
  val consPattern     : constructor -> Pattern.pattern (* replaces crhs *)
  val constypePattern :
    Pattern.Exp.exp * {family:int, typeid:int} -> Pattern.pattern
    (* Model of constructor type is list of disjuncts
       guarded by conditions on "instances", with latent labels.
       First arg is instance, which must be Exp.var, Exp.instance,
       or Exp.bindingInstance. *)
  structure Set : ORD_SET
  sharing type Set.Key.ord_key = constructor
  structure Map : ORD_MAP
  sharing type Map.Key.ord_key = constructor
end
@
\section{Implementing constructors}
<<newcons.sml>>=
structure Constructor : CONSTRUCTOR = struct
  <<operand types>>
  <<internal implementations of types>>

  <<constructor functions>>
end
@ 
Constructors and their types are mutually recursive, with ref cells.
<<internal implementations of types>>=
datatype ('c, 'o, 't) constructor' = CONS of
  { info : ('c, 'o, 't) constructor_info'
  , tag : int
  }
and ('c, 'o, 't) constype' = TY of 
  { name : string option
  , members : ('c, 'o, 't) constructor' list ref
  , used : bool ref
  , typeid : int
  , property : 't
  , family : ('c, 'o, 't) family'
  }
and ('c, 'o, 't) family' = FAM of
  { types : ('c, 'o, 't) constype' list ref
  , nextTypeID : int ref			(* type id of next type *)
  , id : int				(* unique id of this family *)
  , constructors : ('c, 'o, 't) constructor' list ref   (* in reverse order *)
  }
withtype ('c, 'o, 't) constructor_info' =
  { name : string			(* name of this constructor *)
  , operands : 'o operand' list
  , ty : ('c, 'o, 't) constype'		(* type of this constructor *)
  , region : SourceMap.region           (* defining region --- for error messages *)
  , sourcemap : SourceMap.sourcemap     (* to translate those error messages *)
  , property : 'c			(* an arbitrary property *)
  }
@ 
The invariant on [[members]] is that it is in reverse order until the
type is [[used]], at which point it becomes in forward order.
<<constructor functions>>=
fun typeid (TY {typeid, family=FAM {id, ...}, ...}) = {family=id, typeid=typeid}
fun useConstype (TY {used, members, ...}) = 
  if !used then () else (members := rev (!members); used := true)
fun members (ty as TY {members, ...}) = (useConstype ty; !members)
fun tagLimit ty =
  1 + foldl (fn (CONS {tag,...}, n) => Int.max(tag, n)) 0 (members ty)
fun typeName (TY {name,...}) = name
@
<<constructor functions>>=
val unnamedID = 1
val nextFamilyID = ref 1
fun newFamily' property = 
  let val family =  FAM { types = ref [], nextTypeID = ref (unnamedID + 1),
			  constructors=ref [], id = !nextFamilyID }
      val _ = nextFamilyID := !nextFamilyID + 1
      val unnamed = TY {name=NONE, members=ref [], used=ref false,
			typeid=unnamedID, property=property, family=family}
      val FAM { types, ...} = family
  in  family before types := [unnamed]
  end
fun familyID (FAM {id, ...}) = id
@ 
I use linear search for the lookup functions.
<<constructor functions>>=
fun typeFromId' lookup {family, typeid=n} =
  let val FAM {types, nextTypeID, id, ...} = lookup family
      val _ = id = family orelse ErrorMsg.impossible "family id botch"
      val ty as TY {typeid,...} = List.nth(!types, !nextTypeID - n - 1)
      val _ = typeid = n orelse ErrorMsg.impossible "typeid botch"
  in  ty
  end
fun fromId' lookup {family, typeid, tag} =
  let val constype = typeFromId' lookup {family=family, typeid=typeid}
  in  case List.find (fn CONS {tag=tag', ...} => tag = tag') (members constype)
	  of SOME cons => cons
	   | NONE => ErrorMsg.impossible "bad constructor id"
  end
<<constructor functions>>=
fun info (CONS { info, ... }) = info
fun fullId (CONS { info = { ty, ... }, tag }) =
  let val TY { typeid, family, ... } = ty
      val FAM { id = family, ... } = family
  in  {typeid=typeid, tag=tag, family=family}
  end
fun tag (CONS { tag, ... }) = tag
@ 
<<constructor functions>>=
fun operandNamed (CONS { info = {operands, name=consname, ... }, ... }, name) =
  let fun i((opr as (n, _, _)) :: t) = if name = n then opr else i t
	| i [] = Error.errorl ["Constructor ", consname, " has no input named ", name]
  in  i operands
  end
fun operandSelect (CONS { info = {operands, name=consname, ... }, ... }, name, l) =
  let fun i((n, _, _) :: t, h :: t') = if name = n then h else i (t, t')
	| i([], _) = Error.errorl
	                 ["Constructor ", consname, " has no input named ", name]
	| i (_, []) = Impossible.impossible "operand selection"
    in  i (operands, l)
    end
@ 
<<constructor functions>>=
fun unnamedConstype(fam as FAM {id, ...}) =
  typeFromId' (fn _ => fam) {family=id, typeid=unnamedID}
fun freshConstype (f as FAM { types, nextTypeID, ... }, {name}, prop) =
  let val ty = TY {name=SOME name, members=ref [], used=ref false,
		   typeid = !nextTypeID, property=prop, family=f}
  in  nextTypeID := !nextTypeID + 1;
      types := ty :: !types;
      ty
  end
<<constructor functions>>=
fun hasName n (CONS {info={name,...},...}) = n = name
fun tyname (TY {name, ...}) = case name of NONE => "unnamed type" | SOME n => "type "^n

fun addConstructor(c as {ty, name, ...}, ty' as TY {used, members, family, ...}) =
  let val _ = typeid ty = typeid ty'
              orelse ErrorMsg.impossible "constructor type mismatch"
      val tag = length (!members) + 1  (* superstitious about zero tag *)
      val _ = List.exists (fn CONS {tag=tag', ...} => tag = tag') (!members)
              andalso ErrorMsg.impossible "duplicate tags in constructor type"
      val FAM { constructors, ... } = family
  in  if !used then
        Error.errorl ["Cannot add constructor to ", tyname ty',
                      "; it was already used on line ???"]
      else if List.exists (hasName name) (!members) then
        Error.errorl [tyname ty', " already has a constructor named ", name]
      else
        let val c = CONS { info = c, tag = tag }
        in  members := c :: !members; 
            constructors := c :: ! constructors;
            c
        end
  end
<<constructor functions>>=
fun replaceCons (l, c as {name,...}) = 
  let fun r ([], old) = ErrorMsg.impossible "constructor replacement"
        | r ((h as CONS {tag, info={name=name',...}}) :: t, old) =
           if name = name' then 
             let val c = CONS {tag=tag, info=c}
             in  (List.revAppend(old, c :: t), c)
             end
           else
             r(t, h :: old)
  in  r (l, [])
  end
<<constructor functions>>=
fun replaceConstructor(c as {ty, name, ...},
                       ty' as TY {used, family, members, ...}) =
  let val _ = typeid ty = typeid ty'
              orelse ErrorMsg.impossible "constructor type mismatch"
      val _ = List.exists (hasName name) (!members)
              orelse ErrorMsg.impossible "replace nonexisting constructor"
  in  if !used then
        Error.errorl ["Cannot add constructor to ", tyname ty',
                      "; it was already used on line ???"]
      else
        let val (members', c) = replaceCons(!members, c)
        in  members := members'; c
        end
  end
<<constructor functions>>=
fun allTypes (f as FAM {types, ...}) =
  (* reverse order is not OK for instance types, and instruction types should come last *)
  List.filter (fn TY {name, ...} => isSome name) (rev (!types)) @ [unnamedConstype f]

fun constructors' (FAM {constructors=c, ...}) = !c
@
\section{Implementing SLED constructors}
<<sledcons.sml>>=
functor SledConstructorFun
  (structure Patterns : PATTERNS where type Exp.exp = UnifiedExp.exp
   structure Constructor : CONSTRUCTOR
  ) : SLED_CONSTRUCTOR = 
struct
  structure Patterns = Patterns
  structure Pattern = Patterns.Latent
  type disjunct = (Patterns.field, Patterns.latent) Patterns.cons_or_label
                       Patterns.sequence Patterns.disjunct'
  open Constructor
  type operand_property = { relocatable : bool, field : Patterns.field option } 
  structure Syntax = struct
    datatype operand = LITERAL of string | OPERAND of operand_property operand'
  end
  type constructor_property = 
      { branches : Patterns.Latent.pattern list, syntax : Syntax.operand list }
  type constype_property = unit
  type operand = operand_property operand'
  type family = 
    (constructor_property, operand_property, constype_property) family'
  type constructor = 
    (constructor_property, operand_property, constype_property) constructor'
  type constype = 
    (constructor_property, operand_property, constype_property) constype'
  type constructor_info = 
    (constructor_property, operand_property, constype_property) constructor_info'

  <<functions on SLED constructors>>

  structure ConsKey = ConstructorKeyFun(type constructor = constructor
					val id = fullId)
  structure Map = BinaryMapFn(ConsKey)
  structure Set = BinarySetFn(ConsKey)
end
@ 
@ 
\section{Constructors in tables}
<<conskey.sml>>=
functor ConstructorKeyFun(type constructor
			  val id : constructor -> {family:int, typeid:int, tag:int}) : ORD_KEY
= struct
  type ord_key = constructor
  fun compare'tag ({typeid=L1, tag=L2, family=L3}, {typeid=R1, tag=R2, family=R3}) =  
      (case Int.compare (L2, R2) 
        of EQUAL   => (case Int.compare (L1, R1)
			 of EQUAL => Int.compare (L3, R3)
			  | diff => diff)
         | diff    => diff)
  fun compare (c1, c2) = compare'tag (id c1, id c2)
end
@ 
The family stuff is straightforward.
<<functions on SLED constructors>>=
local
  val families = ref IntMap.empty : family IntMap.map ref
in
  fun newFamily p =
    let val fam = newFamily' p
        val _ = families := IntMap.insert(!families, familyID fam, fam)
    in  fam
    end
  fun familyFromId n =
    case IntMap.find(!families, n)
      of SOME fam => fam
       | NONE => Impossible.impossible "family id"
  val fromId = fromId' familyFromId
  val typeFromId = typeFromId' familyFromId
end
@ 
\section{Patterns of constructors and their types}
@ 
What here eliminates impossible disjuncts?
Something ought to; the old code was
\begin{verbatim}
cache[cons] := subst(eliminate_contradictions(p), "nonexistent variable", 0)
                 # can't afford to simplify -- makes it too hard to solve eqns
                 # subst eliminates bad tag conditions
\end{verbatim}
<<functions on SLED constructors>>=
structure Exp = Pattern.Exp
structure P = Pattern
<<parameter substitution>>
fun consPattern cons =
  case info cons
    of {property = {branches=[], ...}, ...} =>
      Impossible.impossible "constructor without branches"
  | cons as {operands, property={branches, ...}, ...} =>
      (P.subst o Exp.multiSubst) (parameterSubstitution cons) (P.orp branches)
@ 
[[parameterSubstitution]] produces a substitution that does the right thing with 
the parameters to a C emission procedure.
I'm really uneasy about this, since I haven't thought through or
gathered all the global assumptions made about different parameters.
Note that, for example, unsigneds of known width don't get narrowed
(are they fields?), but signeds do!
<<parameter substitution>>=
fun parameterSubstitution ({operands, ...} : constructor_info) =
  let fun bind((name, ty, {relocatable, ...}) : operand, map) =
        let val e = Exp.var name
	    fun force e = if relocatable then Exp.force e else e
        in  StringMap.insert(map, name,
               case ty
                 of INTEGER {width=NONE, ...} => force e
                  | INTEGER {width=SOME n, signed=true}  => Exp.narrows(force e, n)
                  | INTEGER {width=SOME n, signed=false} => force e
					(* NOT! Exp.narrowu(force(reloc, e), n) *)
                  | INSTANCE _ => e
            )
        end
      val map = foldl bind StringMap.empty operands
  in  fn n => StringMap.find(map, n)
  end
@ 
As in the old implementation, we get the instance by using the
right-hand sides of all 
the constructors.
We don't bother cacheing anything (yet).
<<functions on SLED constructors>>=
<<unique identifiers>>
<<instance validation>>
fun constypePattern (instance, {family=famid, typeid}) = 
  let val _ = validateInstance instance
      val uid = mkUid()  (* not sure if this is still needed *)
      val constype = typeFromId {family=famid, typeid=typeid}
      fun bindCondition(pat, cond) = P.addConds (Exp.Set.singleton cond) pat
      fun consPat cons =
            let val consid = {typeid = typeid, tag = tag cons, family = famid}
                <<[[sigma]] map inputs of this cons to fetches from input>>
                val q = P.subst (Exp.multiSubst sigma) (consPattern cons)
            in  bindCondition(q,
                              Exp.instanceTagged(instance, {cons=consid, uid=uid}))
            end
      val _ = null (members constype) andalso
              <<impossible: [[constype]] has no members>>
  in  P.seqp [
         Patterns.latentLabel instance,
         P.orp (map consPat (members constype))]
  end
<<instance validation>>=
structure U = UnifiedExp
fun validateInstance(U.VAR _) = ()
  | validateInstance(U.INSTANCE _) = ()
  | validateInstance(U.BINDING_INSTANCE _) = ()
  | validateInstance _ = Impossible.impossible "bogus instance"
@ 
We put the inputs in a table [[t]].
<<[[sigma]] map inputs of this cons to fetches from input>>=
local
  fun addInput ((ipt, ty, {relocatable, ...}) : operand, t) =
    let val i = Exp.instanceInput(instance, {cons=consid, operand=ipt})
        val i = if relocatable then Exp.force i else i
    in  StringMap.insert(t, ipt, i)
    end
  val t = foldl addInput StringMap.empty (#operands (info cons))
in
  fun sigma n = StringMap.find(t, n)
end
@
<<unique identifiers>>=
local
  val n = ref 0
in 
  fun mkUid() = (n := !n + 1; !n)
end
@ 
<<impossible: [[constype]] has no members>>=
let val n = case typeName constype of NONE => "unnamed constype"
                                    | SOME n => "constype " ^ n
in  Impossible.impossible (n ^ " has no members")
end
@ 
\section{Old Icon goo?}
@
An implicit pattern conjoins all the pattern and field names appearing in the opcode 
and operands.
<<*>>=
procedure implicit_pattern(opcode, operands)
  l := []
  every op := !opcode do 
    case type(op) of {
      "pattern" : put(l, Pident(\op.name)) | impossible("unnamed opcode pattern")
      "field"   : put(l, Pident(op.name))
    }
  every ipt := inputs_of_operands(operands) do
    if type(ipt.meaning) == ("field"|"integer"|"constype") then
      put(l, Pident(ipt.name))
  *l > 0 | 
    error("Cannot use implicit pattern with no patterns or fields on lhs (",
          expimage(opcode), ")")
  return Pand(l)
end
@
These auxiliary functions help choose names for constructors.
<<*>>=
procedure iname(opcode)
  local name
  name := ""
  every name ||:= opcode_component_name(!opcode)
  if \lowercons then name := map(name)
  return mapoutbadchars(name)
end

procedure opcode_component_name(op)
  return case type(op) of {
           "string"   : op
           "disjunct" : {
             if *\op.name = 0 then impossible("disjunct with empty name")
             \op.name | "???unnamed disjunct???"
             }
           default : impossible("opcode component", image(op))
         }
end
<<*>>=
procedure mapoutbadchars(name)
  static nonalnum, underscores
  initial {
    nonalnum := string(&ascii -- &letters -- &digits -- '_')
    underscores := repl("_", *nonalnum)
  }
  return map(name, nonalnum, underscores)
end
<<if first time thru, check for unused definitions in [[cons]]>>=
if /checked then {
  checked := 1
  <<check for unused definitions in [[cons]]>>
}
<<check for unused definitions in [[cons]]>>=
every i := 1 to *cons.branches & b := cons.branches[i] do {
  u := copy(b.soln.used)
  every insert(u, pattern_free_variables(b.pat))
  d := copy(b.soln.defined)
  every insert(d, key(cons.rho[1 to *cons.rho - 1]) | inputs_of(cons).name)
  every x := !(d--u--fresh_variables) do
    warning(
      if \cons.rho[1 to *cons.rho-1][x] then "opcode part"
      else if member(b.soln.defined, x) then "equation result"
      else "operand",
      " ", image(x), " not used in constructor ", cons.name,
           if (*cons.branches = 1) then "."
           else " in " || ordinal(i) || " branch.")
}
@
<<check that [[t.type.ntags]] doesn't overflow tag bits>>=
if t.type.ntags >= 2^11 then
  impossible("Too many type tags --- change mclib.nw (struct instance), constructors.nw")
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Utility functions}

\subsection{Input generation}
@
\subsection{Checking constructor types}
The two [[enforce]] functions distinguish between typed and untyped constructors
by comparing their argument (a constructor type) to the anonymous type.
<<*>>=
procedure enforce_instance(ct)
  return instructionctype ~=== ct | impossible("instance of untyped constructor")
end
<<*>>=
procedure enforce_closure(ct)
  return instructionctype  === ct | impossible("closure of typed constructor")
end
@
\subsection{Miscellany}
[[cons_named]] produces the constructor named [[s]] and issues an 
error if no such constructor exists.  [[is_constructor]] tests if 
[[s]] is a constructor and prints an optional message if it is not.
<<*>>=
procedure cons_named(s) 
  return is_constructor(s, error)
end
procedure is_constructor(s, p)
  return \constructors[s | iname([s])] | (\p)(image(s), " is not a constructor name")
end
<<*>>=
procedure discard_cons_named(s)
  if member(constructors, s <- (s | iname([s]))) then
    delete(constructors, s)
  else
    warning("There is no constructor named ", s)
  return
end
<<*>>=
procedure ordinal(n)
  return case n of {
    1 : "1st"
    2 : "2nd"
    3 : "3rd"
    default : n || "th"
  }
end
@
\section{C support for closures}
Closures are numbered within a particular constructor, except for the first.
<<*>>=
procedure emit_original_closure_functions(pp, cons, b)
  local suffix   
  every cl := subterms_matching(b, "Sclosure") do
    emit_original_closure_function(pp, cons, cons.name || <<suffix with update>>, cl) 
  return
end
<<suffix with update>>=
(if /suffix then (suffix := 1, "") else "_" || (suffix +:= 1))
@
The idea with a closure is to ferret out all the free variables and stuff them
into a custom closure.  The trick is, we don't want to use {\em instance}-valued
variables; we want the components of the instance.  Step 1, then, is to grab all
the instance selections, noting the instances that we're not interested in.
Step 2 will add all the free variables.
The things to save,
are the selections and free variables that aren't selected from.

Everything to save is put in the closure.
Equivalent expressions are to be saved only once, so we use a table mapping things to be 
saved to their names in the closure.
[[closurenametab]] computes that table.

The definition of a closure type requires the inverse of that table.
<<*>>=
procedure emit_original_closure_function(pp, cons, name, cl)
  local selections, selected, free, save, upc
  <<make [[selections]], [[selected]], [[free]] hold selections, things selected from, and free variables>>
  nt := closurenametab(selections ++ free -- selected)
  mt := meaningtab(nt, cons)
  emit_original_closure_typedef(pp, name, cons, mt)
  emit_original_closure_relocfn(pp, name, cons, mt)
  emit_original_closure_function_def(pp, name, cl, nt)
  emit_closure_header_def(pp, name, name || "_app", cl)
  <<make [[cl.creation]] to create closure and emit placeholder>>
  return
end
@
<<make [[cl.creation]] to create closure and emit placeholder>>=
<<make [[l]] a list of assignments by using the name table [[nt]]>>
upc := if subterms_matching(\cl.conditions | cl.disjunct, "Epc", "Epc_known") then 1
       else 0
cl.creation := Sstmts([
  literal(template_to_list("create-closure.t", 
                                "name", name, "save", l, "clofun", name || "_app")), 
  disjunct_to_emission(place_holder(cl.disjunct))])
<<create-closure.t>>=
$t{ %{name}_Closure _c;
_c = (%{name}_Closure) mc_create_closure_here(sizeof *_c, &%{clofun}_closure_header);
%{save}/* this line intentionally left blank */$b
}  
<<create-closure-at.t>>=
$t{ %{name}_Closure _c;
_c = (%{name}_Closure) mc_create_closure_at_offset(sizeof *_c, &%{clofun}_closure_header, %offset);
%{save}/* this line intentionally left blank */$b
}  
@ 
<<make [[l]] a list of assignments by using the name table [[nt]]>>=
l := []
s := set()
every e := key(nt) & not member(s, nt[e]) do {
  insert(s, nt[e])
  put(l, "_c->v." || nt[e] || " = " || pretty(e) || ";$n")
}
s := &null # enable garbage collection
@ 
Added this to restructure so we could emit one header per closure
function in the optimized case (instead of one header per encoding
function).\change{34} 
<<*>>=
procedure emit_closure_header_def(pp, name, clofun, cl)
  local upc
  upc := if subterms_matching(\cl.conditions | cl.disjunct, "Epc", "Epc_known") then 1
         else 0
  emit_template(pp, "closure-header.t", "clofun", clofun, "name", name, "uses-pc", upc)
  return
end
<<closure-header.t>>=
static struct closure_header %{clofun}_closure_header = $t
{ %{clofun}, %{name}_relocfn, %{uses-pc}, sizeof (struct %{name}_closure) };$b
@   
<<make [[selections]], [[selected]], [[free]] hold selections, things selected from, and free variables>>=
every selections | selected | free := set()
every s := subterms_matching(cl.disjunct | \cl.conditions, "Einstance_input") do {
  insert(selections, s)
  insert(selected, s.x)
}
every insert(free, free_variables(cl.disjunct | \cl.conditions))
@
<<*>>=
procedure closurenametab(save)
  local namecounts, saved, name
  every namecounts | t := table()
  saved := set()
  every e := !save do
    if eprime := !saved & exps_eq(e, eprime) then
      t[e] := t[eprime]
    else {
      insert(saved, e)
      <<set [[name]] to the proper name of the field for [[e]]>>
      t[e] := name
    }
  return t
end
<<set [[name]] to the proper name of the field for [[e]]>>=
name := case type(e) of {
  "string" : e
  "Einstance_input" : e.name
  default : impossible("type of saved exp")
}
if /namecounts[name] then 
  namecounts[name] := 1
else 
  name ||:= "__" || (namecounts[name] +:= 1)
@
To compute the closure type, we pack the names;
big ones first, then little ones.
First we invert the table, so that the names are the unique keys in [[u]].
<<*>>=
procedure emit_original_closure_typedef(pp, name, cons, t)
  l := []
  every fname := key(t) do 
    put(l, case type(t[fname]) of {
             "null"     : "$cint "   || fname || ";"
             "string"   : "$cRAddr " || fname || ";"
             "constype" : impossible("failed to eliminate an instance")
           })
  every fname := key(t) do
    put(l, case type(t[fname]) of {
             "field"   : "$cunsigned " || fname || ":" || fwidth(t[fname]) || ";"
             "integer" : "$cint "      || fname || ":" || t[fname]         || ";"
           })
  emit_template(pp, "closure-type.t", "name", name, "decls", l)
end
@
<<closure-type.t>>=
typedef struct %{name}_closure {$t
ClosureHeader h;
ClosureLocation loc;
struct { $t${%decls $b$c$}} v;$b
} *%{name}_Closure;
<<*>>=
procedure emit_original_closure_relocfn(pp, name, cons, t)
  local calls
  calls := []
  every fname := key(t) & type(t[fname]) == "string" do
     put(calls, template_to_list("reloc-call.t", "irec", "v", "input", fname))
  emit_template(pp, "constructor-labels.t", "ptrtype", name || "_Closure",
                                 "name", name, "calls", calls)
  return
end
@
The  emitter code in [[Cexp]] assumes that the closure is stored in [[_c]].
<<*>>=
procedure emit_original_closure_function_def(pp, name, cl, t)
  local es
  tt := copy(t)
  every k := key(t) do tt[k] := literal("_c->v." || tt[k])
  tt[the_global_pc] := Eforce(Eclosure_loc())
  PPxwrite(pp, "static void ", name,
               "_app (RClosure c,$o Emitter emitter,$o FailCont fail) {$t$n",
               name, "_Closure _c = (", name, "_Closure) c;$n")
  es := emitterstyle
  emitterstyle := "closure"
  PPxwrite(pp, pretty(
     super_simplify(Sif([Sguarded(subst_table_elements(cl.conditions, tt), 
                                  disjunct_to_emission(
                                      subst_table_elements(cl.disjunct, tt))),
        ### disjunct_to_emission should be changed to include width conditions &c
                   Sguarded(1, 
                      Sfail("Conditions not satisfied for constructor " || name))]))))
  emitterstyle := es
  PPxwrite(pp, "$b$n}")
end
<<apply-fun.t>>=
static void %{name}_app (RClosure c, Emitter emitter, FailCont fail) {
<<*>>=
procedure find_input(name, cons)
  return input_named(cons, name)
end
<<*>>=
procedure meaningtab(t, cons)
  u := table()
  every k := key(t) do
    (u[t[k]] := known_to_fit(find_input, k, cons).meaning) | 
        impossible("unknown free variable ", k)
  return u
end
@
\subsection{Extracting relocatable addresses from instances and closures}
There are three possible sources of relocatable addresses:
the program counter, relocatable inputs, or constructors (input or applied).

[[uses_pc]] determines if a constructor
{\em directly} uses the program counter.
Conservatively, we estimate that a constructor uses the program
counter if any of its branches have labels, or
if some constructor used in {\em any} of the constructor's
output patterns uses the program counter.
This is overly conservative but easy to implement.
<<*>>=
procedure uses_pc(x)
  static pccache
  initial pccache := table()
  if not member(pccache, x) then {
    pccache[x] := 0
    type(x) == "constructor" | impossible("uses_pc")
    if pattern_label_names((!x.branches).pat) |
       uses_pc(constructors_applied_in((!x.branches).pat)) then
      return pccache[x] := 1
  }
  return 0 < pccache[x]
end
@
[[uses_reloc]] determines if the given constructor
can depend on the label of some relocatable address.
[[uses_reloc]] holds if [[uses_pc]] holds
or if a relocatable address is in the constructor's inputs,
or if [[uses_reloc]] holds for some constructor-typed input
or for any constructor used in an output pattern.
<<*>>=
procedure uses_reloc(x)
   static cache
   initial cache := table()
   if not member(cache, x) then {
     cache[x] := 0
     case type(x) of {
       "constype"    : if uses_reloc(kept_constructors(x)) then return cache[x] := 1
       "constructor" :
         if inputs_of(x, "string") | uses_pc(x) |
            uses_reloc(inputs_of(x, "constype").meaning |
                       constructors_applied_in((!x.branches).pat))
         then
           return cache[x] := 1
       default : impossible("uses_reloc")
     }
   }
   return 0 < cache[x]
end
@

[[ptrtype]] is the exact pointer type of this instance or closure.
[[irec]] is the record containing the inputs.

<<constructor-labels.t>>=
static void %{name}_relocfn(RClosure c, RelocCallback f, void *closure) {$t
%ptrtype _c = (%ptrtype) c;
%calls$b}
<<reloc-call.t>>=
(*f)(closure, _c->%irec.%input);
<<cons-call.t>>=
$t${(*(_c->%irec.%input.h->relocfn))$o((Instance*)(&_c->%irec.%input), f, closure);$}$b
<<no-labels.t>>=
static void %{name}_relocfn(RClosure c, RelocCallback f, void *closure) {
  return;
}
@
\subsection{Emitting}
<<*>>=
procedure emit_emitter_body(pp, cons)
  b := emitter_body(cons)
  emit_closure_functions(pp, cons, b)
  emit_template(pp, "emitter-body.t", 
                "safename", Cnoreserve(cons.name), "args", arg_decls(cons),
                "class", if \indirectname then "static " else "")
  PPxwrites(pp, pretty(b))
  if \gen_counters then
    PPxwrites(pp, "$n", cons.name, "_ctr++;")
  PPxwrite(pp, "$b$n}")
  return
end
<<emitter-body.t>>=
%{class}void %safename(%args) {$t
@
\section{Optimizing closures}
We don't have to number optimized closures; their naming is arbitrary.
<<*>>=
procedure emit_optimized_closure_functions(pp, cons, b)
  pushtrace("CLO")
  every cl := subterms_matching(b, "Sclosure") do
    emit_optimized_closure_function(pp, cons, cons.name, cl) 
  poptrace()
  return
end
@
We really ought to add a string type to the closure, so that we
could give the name of the constructor when conditions aren't
satisfied in the closure.  As it is, I use the same error message for
each constructor---otherwise they won't all use the same closure function!
<<*>>=
procedure emit_optimized_closure_function(pp, cons, name, cl)
  local selections, selected, free, save, upc, latevars, clo, subst, body
  latevars := set()
  every insert(latevars, inputs_of(cons, "string").name)
  body := 
     super_simplify(Sif([Sguarded(cl.conditions, disjunct_to_emission(cl.disjunct)),
        ### disjunct_to_emission should be changed to include width conditions &c
                         Sguarded(1, 
                            Sfail("Conditions not satisfied for unnamed constructor"))
                        ]))
  p := hoist(pp, Elambda(sort(latevars), body), latevars)
  clo := p.e # is a closure
  clo := apply_subst(clo, p.sigma)
  free := set(); every insert(free, free_variables(clo))
  free := sort(free)
PPwrite(pp, "/****************")
PPxwrite(pp, "CLOSURE IS:$t $o", ppexpimage(clo), "$b")
PPwrite(pp, "****************/")
  <<make [[cl.creation]] to create optimized closure [[clo]] and emit placeholder>>
  return
end
@ N.B. I think there's a potential botch because [[latevars]] doesn't
include relocatable addresses hidden inside constructor-typed
arguments.
@
<<make [[cl.creation]] to create optimized closure [[clo]] and emit placeholder>>=
l := []
every i := 1 to *clo.values do
  put(l, pretty(Gasgn(Eclosure_val(i),  clo.values[i])) || "$n")
every i := 1 to *clo.addresses do
  put(l, pretty(Gasgn(Eclosure_addr(i), clo.addresses[i])) || "$n")
upc := if subterms_matching(\cl.conditions | cl.disjunct, "Epc", "Epc_known") then 1
       else 0
cl.creation := Sstmts([
  literal(template_to_list("create-closure.t", "name", clo.ty, "clofun", clo.fun, 
                           "uses-pc", upc, "save", l)),
  disjunct_to_emission(place_holder(cl.disjunct))])
@ 
<<*>>=
record Elambda(formals, body)
record hoisted(e, sigma)        # pair containing exp, substitution
record arrow(v, e)              # part of a substitution
procedure make_early(v, e, sigma)
  v := fresh_variable(v)
  return hoisted(v, push(sigma, arrow(v, e)))
end

procedure make_late(v, e, sigma)
  return hoisted(e, sigma)
end

procedure make_time(e, latevars)
  return if islate(e, latevars) then make_late else make_early
end

procedure islate(e, latevars)
  return case type(e) of {
    "string" : member(latevars, e)
    "list"   : islate(!e, latevars)
    default  : 1
  }
end
<<*>>=
record Eclosure(ty, fun, headertype, values, addresses)

procedure hoist(pp, e, latevars)
  local body, sigma, sigma1, p, free, freeset, clo, clofun, closubst, early, late, hd
  local values, addresses
  x := case type(e) of {
    "string"  : hoisted(e, [])
    "integer" : make_early("lit", e, []) 
    "list"    : hoistlist(pp, e, latevars)
    "Elambda" : {
       p := hoist(pp, e.body, set(e.formals))
       body := p.e
       sigma := p.sigma
       <<make [[addresses]] and [[values]] free vars of body (in order of appearance)>>
       if \lateconst then {
         <<using [[sigma]], push constants back into [[body]] and out of [[values]]>>
       }

       clo := fresh_variable("clo")
       <<make [[closubst]] change addresses and values to select from [[clo]]>>
       body := apply_subst(body, closubst)

       clotype := closure_type(pp, values, addresses)
       clofun := closure_function(pp, clotype, addresses, body)
       hd := closure_header_type(pp, clofun, clotype, body)
       <<make [[cloargs]] the list of closure args, using [[values]] and [[sigma]]>>
       p := hoistlist(pp, cloargs, latevars)
       make_time(p.e, latevars)("closure", 
            Eclosure(clotype, clofun, hd, p.e, apply_subst(addresses, sigma)), p.sigma)
    }
    "Epc" | "Epc_known" : make_late("pc", e, [])
    <<other cases for hoisting>>
    <<generated cases for hoisting>>
    default : impossible("hoisting ", image(type(e)))
  }
### PPxwrites(pp, "Hoisting ", ppexpimage(e), "$t$ngot $t${$o", ppexpimage(x.e), 
###                       "$}$b$nwith")
### showsigma(pp, x.sigma)
### PPxwrite(pp, "$nso, when applied, have $t$o${", 
###              ppexpimage(apply_subst(x.e, x.sigma)),
###                  "$}$b$b$n")
  return x
end
<<generated cases for hoisting>>=
@ 
A value is an address if it's a formal parameter or if it's a suitable
element of an instance input:
<<*>>=
procedure is_address(e, addressparms)
  return e === !addressparms |
         (type(e) == "Einstance_input", 
          type(input_named(e.cons, e.name).meaning) == "string")
end          
@ 
Preserving order here helps keep us from creating
closure functions that differ only by a permutation of arguments.
We have to apply [[sigma]], and see what sort of value the free
variable stands for, in order to classify it as a value or an address.
<<make [[addresses]] and [[values]] free vars of body (in order of appearance)>>=
every addresses | values := []
freeset := set()
every v := free_variables(body) & not member(freeset, v) & 
      x := apply_subst(v, sigma) 
do {
  insert(freeset, v)
  put(if is_address(x, e.formals) then addresses else values, v)
}
<<using [[sigma]], push constants back into [[body]] and out of [[values]]>>=
l := []
every f := !values do
  if x := constant(apply_subst(f, sigma)) then
    body := apply_subst(body, arrow(f, x))
  else
    put(l, f)
values := l
<<make [[closubst]] change addresses and values to select from [[clo]]>>=
closubst := []
every i := 1 to *values do
  put(closubst, arrow(values[i], Eclosure_val(i)))
every i := 1 to *addresses do
  put(closubst, arrow(addresses[i], Eclosure_addr(i)))
<<make [[cloargs]] the list of closure args, using [[values]] and [[sigma]]>>=
cloargs := []
every put(cloargs, apply_subst(!values, sigma))
<<other cases for hoisting>>=
"table" : {
  kl := []; every k := key(e) & e[k] ~= 0 do put(kl, k)
  hl := hoistlist(pp, kl, latevars)
  sigma := hl.sigma
  hl := hl.e
  if x := !hl & not islate(x, latevars) then {
    t := table(0)
    every k := kl[i := 1 to *kl] & x := hl[i] & not islate(x, latevars) do
      t[x] +:= e[k]
    early := make_early("sum", t, sigma)
    sigma := early.sigma
    early := early.e
  } else 
    early := &null
  if islate(!hl, latevars) then {
    t := table(0)
    every k := kl[i := 1 to *kl] & x := hl[i] & islate(x, latevars) do
      t[x] +:= e[k]
    t[\early] +:= 1
    make_late("sum", t, sigma)
  } else {
    make_early("sum", \early | 0, sigma)
  }
}
<<other cases for hoisting>>=
"Eorb" : {
  l := hoistlist(pp, flatten(e, "Eorb"), latevars)
  every early | late := []
  every x := !l.e do put(if islate(x, latevars) then late else early, x)
  if *late > 0 then
    if *early = 0 then 
      make_late("or", unflatten(late, Eorb, 0), l.sigma)
    else {
      early := make_early("or", unflatten(early, Eorb, 0), l.sigma)
      push(late, early.e)
      make_late("or", unflatten(late, Eorb, 0), early.sigma)
    }
  else 
    make_early("or", unflatten(early, Eorb, 0), l.sigma)
}
<<other cases for hoisting>>=
"set" : {
  sigma := []
  s := set()
  every x := !e do {
    p := hoist(pp, x, latevars)
    insert(s, p.e)
    sigma := compose(sigma, p.sigma)
  }
  hoisted(s, sigma)
}
@ 
For equations, we try a funky heuristic, namely, if we see a zero on
the right-hand side, {\em don't} hoist it.
<<other cases for hoisting>>=
"eqn" : {
  sigma := []
  m := make_early
  _a0 := hoist(pp, e.left, latevars)
  sigma := compose(sigma, _a0.sigma)
  _a0 := _a0.e
  if islate(_a0, latevars) then m := make_late
  if \latezero & untable(e.right) === 0 then {
    _a2 := 0
    m := make_late
  } else {
    _a2 := hoist(pp, e.right, latevars)
    sigma := compose(sigma, _a2.sigma)
    _a2 := _a2.e
    if islate(_a2, latevars) then m := make_late
  }
  if not (_a0 === e.left, _a2 === e.right) then
    e := eqn(_a0, e.op, _a2)
  m("eqn", e, sigma)
}
@ 
We can't hoist a guard!  And we might as well not hoist~1 when it's
just the guard that's always satisfied.
<<other cases for hoisting>>=
"Sguarded" : {
  p := if guard_always_satisfied(e.guard) then hoisted(1, [])
       else hoist(pp, e.guard, latevars)
  q := hoist(pp, e.x, latevars)
  hoisted(Sguarded(p.e, q.e), compose(p.sigma, q.sigma))
}
"Sepsilon" : hoisted(e, [])
@ 
For [[Sfail]], we ought to be able to keep track of the types of
variables that are hoisted, so we could hoist both the message and, if
need be, the arguments.
<<other cases for hoisting>>=
"Sfail"    : hoisted(e, [])
@ 
For emission, we ought to do something extra special.
We ought {\em always} to hoist emission, converting unknown tokens
into placeholders as we go.  Then we can build closures for the
remaining tokesn.  Perhaps if we have a type mechanism, we can do that
one day.

For now, we prevent hoisting by keeping [[Stoken]]s late.
<<other cases for hoisting>>=
"Stoken" : {
  p := hoist(pp, e.x, latevars)
  hoisted(Stoken(p.e, e.n, e.offset), p.sigma)
}
@ 
For a particular instance input, we have to check its type to know
whether it is early or late.
<<other cases for hoisting>>=
"Eforce" : {
  p := hoist(pp, e.x, latevars)
  hoisted(Eforce(p.e), p.sigma)
}
<<*>>=
procedure hoistlist(pp, l, latevars)
  local sigma, newl, e
  sigma := []
  newl := []
  every e := !l do {
    p := hoist(pp, e, latevars)
    put(newl, p.e)
    sigma := compose(p.sigma, sigma)
  }
  return hoisted(newl, sigma)
end
@ 
The function [[closure_type]] looks at the number of free and bound
variables and finds (or emits) a type suitable for use as the closure.
If it has to emit a new type, it also emits a ``reloc function'' to go
with it.      
<<*>>=
procedure closure_type(pp, values, addresses)
  static closure_types
  local clname, calls
  initial closure_types := set()
  clname := "O" || *addresses || "_" || *values
  if not member(closure_types, clname) then {
    insert(closure_types, clname)
    every calls | l := []
    every i := 1 to *addresses do {
      put(l, " $cRAddr a" || i || ";")
      put(calls, template_to_list("reloc-call.t", "irec", "v", "input", "a" || i))
    }
    every i := 1 to *values do
      put(l, " $cunsigned u" || i || ";")
    emit_template(pp, "closure-type.t", "name", clname, "decls", l)
    emit_template(pp, "constructor-labels.t", "ptrtype", clname || "_Closure",
                                 "name", clname, "calls", calls)
  }
  return clname
end
@ 
For compose, the right-hand substitution is applied first.
<<*>>=
procedure compose(sigma1, sigma2)
  return if *sigma1 = 0 then sigma2
         else if *sigma2 = 0 then sigma1
         else push(sigma1, sigma2)
end
<<*>>=
procedure apply_subst(e, sigma)
  return case type(sigma) of {
           "list" : {
               every s := !sigma do e := apply_subst(e, s)
               e
             }
           "arrow": subst(e, sigma.v, sigma.e)
           default :  impossible("substitution")
         }
end
procedure apply_subst_list(e, sigma)
  every i := 
  return case type(sigma) of {
           "list" : apply_subst_list(e, sigma, 1)
           "arrow": subst(e, s.v, s.e)
           default :  impossible("substitution")
         }
end
<<*>>=
procedure showsigma(pp, sigma)
  case type(sigma) of {
    "arrow" : PPxwrites(pp, "$t$n${", sigma.v, " --> ", 
                        ppexpimage(sigma.e), "$}$b")
    "list"  : every showsigma(pp, !sigma)
    default : impossible("substitution")
  }
  return
end
<<*>>=
global closure_functions_postfix
procedure emit_closure_functions_postfix(pp, interfacebasename)
  if *\closure_functions_postfix > 0 then {
    PPxwrite(pp, "/*****************************$t")
    every k := key(\closure_functions_postfix) do
      PPxwrite(pp, "${", k, " = $t$c", closure_functions_postfix[k], "$b$}")
    PPxwrite(pp, "$b$n****************/")
  }
  PPxwrites(pp, "ClosurePostfix ", 
                mapoutbadchars(interfacebasename), "_clofuns[] = {$t")
  every k := key(\closure_functions_postfix) do
    PPxwrites(pp, "$n{ ", k, ", ", image(closure_functions_postfix[k]), " }, ")
  PPxwrites(pp, "$n{ (ApplyMethod) 0, (char *) 0 }")
  PPxwrite(pp, "$b$n};")
  return
end
<<*>>=
procedure closure_function(pp, cloty, addresses, body)
  static cache, count
  local bodyimage, es, orig_body, bytecode
  initial { every closure_functions_postfix | cache := table(); count := 0 }
  tt := table()
  every i := 1 to *addresses do tt[addresses[i]] := Eclosure_addr(i)
  tt[the_global_pc] := Eforce(Eclosure_loc())
  orig_body := body
  body := subst_table_elements(body, tt)
  bodyimage := expps(body)
  if /cache[bodyimage] then {
    cache[bodyimage] := "_clofun_" || (count +:= 1)
    closure_functions_postfix[cache[bodyimage]] := bodyimage
    verbose("New closure function for \n", bodyimage)
    PPxwrite(pp, "/* CLOSURE FUNCTION _clofun_", count, " is $t$n", bodyimage, "$b$n */")
    bytecode := expbc(body) || bc_halt()
    PPwrite(pp, "/* bytecode (", *bytecode, ") is ", image(bytecode), " */")
    <<emit new closure function numbered [[count]] and put it in cache>>
  }
  return cache[bodyimage]
end
<<emit new closure function numbered [[count]] and put it in cache>>=
es := emitterstyle
emitterstyle := "closure"
PPxwrite(pp, "static void _clofun_", count, 
             "(RClosure c,$o Emitter emitter,$o FailCont fail) {$t$n",
             cloty, "_Closure _c = (", cloty, "_Closure) c;$n")
PPxwrite(pp, pretty(body))
emitterstyle := es
PPxwrite(pp, "$b$n}")
@ 
Added this so we could emit one header per closure
function in the optimized case (instead of one header per encoding
function).\change{34} 
<<*>>=
procedure closure_header_type(pp, clofun, clotype, body)
  local upc
  static cache
  initial cache := table()
  if /cache[clofun] then {
    cache[clofun] := clofun || "_closure_header"
    upc := if subterms_matching(body, "Epc", "Epc_known") then 1 else 0
    emit_template(pp, "closure-header.t", 
                              "clofun", clofun, "name", clotype, "uses-pc", upc)
  }
  return cache[clofun]
end




<<internal [[constype]]>>=
@ If the constructor type has not been [[used]], its [[members]] are
in reverse order of declaration.  Once is has been [[used]], the
[[members]] are in order of declaration.
