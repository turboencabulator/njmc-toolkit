% l2h ignore change {
\chapter{Generation of disassembler}
We can reuse the encoding interface, since the assembly stuff is an
implementation of it.
<<*>>=
link pretty
procedure emit_disassembler(outfilename)
  local constypes, constype
  verbose("Emitting disassemblers")
  f := openfile(outfilename, "w") |
    error("Could not open ", image(outfilename), " for writing")
  pp := PPnew(f)

  pushtrace("DIS")
  every create_input_print_proc(pp, inputs_of(kept_constructors()))
  constypes := set()
  every insert(constypes, kept_constructors().type)
  every emit_constype_disassembler(pp, !constypes)
  return
end
@ 
<<*>>=
procedure emit_constype_disassembler(pp, constype)
  emit_template(pp, "disassembler-body.t", "name", (\constype).name | "instruction")
  PPwrite(pp, "match [next] pc to")
  l := []
  every push(l, kept_constructors(constype)) # reverse order
  every emit_disassembler_match(pp, !l)
  PPwrite(pp, "endmatch")
  PPxwrite(pp, "return next;$b$n}$n")
  PPwrite(pp)	# flush prettyprinter
  return
end
<<disassembler-body.t>>=
unsigned disassemble_%name(void *state, unsigned pc) {$t
unsigned next;
@ 
[[emit_disassembler_match]] emits a line in a matching statement for
constructor [[cons]].
Right now we emit a bunch of print statments flagrantly borrowed from
the assembler encoding stuff.  
Eventually, we will just want indirect calls on encoding procedures.
<<*>>=
procedure emit_disassembler_match(pp, cons) 
  local asmname
  PPxwrites(pp, "| $t$t$t${", cons.name, "(")
  <<emit operands separated by commas>>
  PPxwrites(pp, ")$} => $b$o")
  asmname := consname2asm(cons)
  if *asmname > 0 & /postfix then
    emit_asm_printf(pp, "%s", image(asmname))
  every o := !asmoperands(cons) do
    case type(o) of {
      "literal" : emit_asm_printf(pp, "%s", image(o.s))
      "input"  : 
          PPxwrites(pp, "$n", 
                        create_input_print_proc(pp, o), "(", Cnoreserve(o.name), ");")
      default : impossible("operand type")
    }
  if *asmname > 0 & \postfix then
    emit_asm_printf(pp, "%s", image(asmname))
  if cons.type === instructionctype then
    emit_asm_printf(pp, "\n")
  PPxwrite(pp, "$b$b")
end
<<emit operands separated by commas>>=
pfx := ""
every ipt := inputs_of(cons) do {
  PPxwrites(pp, pfx, ipt.name)
  pfx := ", $o"
}
