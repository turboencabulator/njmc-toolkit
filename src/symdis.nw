% -*- mode: Noweb; noweb-code-mode: icon-mode -*-
% l2h ignore change {
\chapter{A symbolic disassembler}
The idea here is to emit an interface giving a symbolic representation
of instructions, plus a disassembler that targets that representation.
An emit function wouldn't hurt either, but it can wait.
<<*>>=
link pretty
procedure emit_symbolic_disassembler(outfilename)
  local constypes, constype, rty, indarg, m
  verbose("Emitting symbolic disassemblers")
  f := openfile(m := outfilename || ".m", "w") |
	error("Could not open ", image(m), " for writing")
  pp := PPnew(f)

  PPwrite(pp, "#include <mclib.h>")
  PPwrite(pp, "#include <", outfilename, ".h>")

  pushtrace("SYMDIS")
  every constype := !\all_types | instructionctype do {
    rty := if constype === instructionctype & /encode_as_data then "void"
           else constype.name || "_Instance"
    indarg := ", struct " || (\indirecttype) || " *create"
    PPxwrite(pp, rty, " disassemble_", constype.name,
	     "(ProgramCounter pc", \indarg | "", ") {$t")
    PPwrite(pp, "match pc to")
    l := []
    every push(l, kept_constructors(constype)) # reverse order
    every emit_symbolic_disassembler_match(pp, !l)
    PPxwrite(pp, "endmatch$b$n}$n")
  }
  return
end
@ 
[[emit_symbolic_disassembler_match]] emits a line in a matching statement for
constructor [[cons]].  
Here come the calls on encoding procedures.
We have to use a hack on the operands to work around the infamous
``rethink projection'' bug.
<<*>>=
procedure emit_symbolic_disassembler_match(pp, cons) 
  local asmname, pfx, call
  call := if \indirecttype then "(*create->" || Cnoreserve(cons.name) || ")"
          else cons.name
  PPxwrites(pp, "| $t$t$t${", cons.original_name, "(")
  <<emit operands separated by commas>>
  PPxwrites(pp, ")$} => $b$o",
	    if cons.type === instructionctype & /encode_as_data then "" else "return ",
	    call, "${($t$t")
  pfx := ""
  every ipt := inputs_of(cons) do {
    PPxwrites(pp, pfx)
    case type(ipt.meaning) of {
      "integer" | "field" | "null"  : PPwrites(pp, operand_hack(ipt))
      "string" : PPwrites(pp, "int_to_raddr(", operand_hack(ipt), ")")
      "constype" : PPwrites(pp, "disassemble_", ipt.meaning.name, "(",
			    operand_hack(ipt),
			    if \indirecttype then ", create" else "", ")")
      default    : impossible("Bad operand value", type(ipt.meaning))
    }
    pfx := ", $o"
  }
  PPxwrite(pp, "$b$b)$};$b$b")
  return
end
<<emit operands separated by commas>>=
pfx := ""
every ipt := inputs_of(cons) do {
  PPxwrites(pp, pfx, operand_hack(ipt))
  pfx := ", $o"
}
<<*>>=
procedure operand_hack(ipt)
  return "the_" || ipt.name
end
