
How to build a checker for a new target.

1. Edit makefile and add the name of your new target to 
   the variable ARCHS.

2. The checker requires the following files:

   $(TARGET).spec -- contains the target's specification.
   $(TARGET)-name.spec -- contains assembly syntax specification.
	    This specification could be empty, if $(TARGET).spec
	    completely specifies the assembly syntax.
   $(TARGET)-checker.s -- contains any directives that
            must appear at the beginning of an assembly file
            on the target.  See {mips,sparc,pentium}-checker.s.
   $(TARGET)-check.spec -- contains "discard" and "keep" directives
	    that choose which constructors to check.  
            This file could be empty if the user wants to check
            all constructors.
   $(TARGET)-bits.c -- contains the code for "emitbits",
	    which emits binary data using assembly pseudo-ops.
	    See mips-bits.c
   $(TARGET)-bits.h -- the signature for "emitbits".  
	    See mips-bits.h.

3. Once all these files exist, execute:
   make $(TARGET)

   There are two rules that MUST be executed on the target
   architecture: "chkraddr" and "do$(TARGET)".
   The "chkraddr" rule computes the start address of the
   text section in an object file.
   The "do$(TARGET)" rule runs the shell scripts that
   assemble and disassemble the generated assembly files
   and that report errors to the user.
   
 

   
   End of README
echo emitbits.nw 1>&2
sed 's/^-//' >'emitbits.nw' <<'End of emitbits.nw'
The following emitters emit raw bits using pseudo-ops 
in the target architecture's assembly language.  
They are used by the toolkit checker to compare the output of the
toolkit to the binary output produced by the target's assembler.

We start with the Pentium.
<<external declarations>>=
void emitbits(unsigned long val, unsigned n);
<<pentium bits emitter>>=
#include <mclib.h>
#include <assert.h>
#include <stdio.h>
void emitbits(val, n) unsigned long val; unsigned n; {
  switch (n) {
  case sizeof(unsigned char):  
    printf("\t.byte 0x%01x\n", (unsigned char)val); break; 
  case sizeof(unsigned short): 
    printf("\t.word 0x%04x\n", (unsigned short)val); break; 
  case sizeof(unsigned):       
    printf("\t.long 0x%08x\n", val); break; 
  default: assert(0); 
  }  
  addlc(n);
}
@ The MIPS and SPARC directives are identical.
<<mips bits emitter>>=
#include <mclib.h>
#include <assert.h>
#include <stdio.h>
void emitbits(val, n) unsigned long val; unsigned n; {
  switch (n) {
  case sizeof(unsigned char):  
    printf("\t.byte 0x%01x\n", (unsigned char)val); break; 
  case sizeof(unsigned short): 
    printf("\t.half 0x%04x\n", (unsigned short)val); break; 
  case sizeof(unsigned):       
    printf("\t.word 0x%08x\n", val); break; 
  default: assert(0);
  }  
  addlc(n);
}
  
<<sparc bits emitter>>=
<<mips bits emitter>>
@ 
I am guessing that the Alpha emitter is the same as the 
MIPS.
<<alpha bits emitter>>=
<<mips bits emitter>>

<<header>>=
<<external declarations>>
End of emitbits.nw
exit 0;
------------------------------------------------
Mary Fernandez          AT&T Research	
mff@research.att.com    600 Mountain Ave, 2C-147A
908-582-6567            Murray Hill, NJ 07974
